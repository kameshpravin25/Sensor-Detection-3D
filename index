<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Sensor Detection — Pin-Level Probing Simulation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { height:100%; margin:0; font-family: Arial, Helvetica, sans-serif; }
    #detectedBox {
      position: absolute; left: 12px; top: 12px;
      background: rgba(0,0,0,0.7); color: #fff; padding: 8px 12px;
      border-radius: 8px; z-index: 20;
    }
    #hint {
      position: absolute; left: 12px; top: 72px;
      background: rgba(255,255,255,0.9); color: #111; padding: 8px 12px;
      border-radius: 8px; z-index: 20; font-size: 13px; max-width: 360px;
    }
    #probePanel {
      position: absolute; right: 12px; top: 12px; z-index: 20;
      width: 360px; max-height: 78vh; overflow:auto;
      background: rgba(0,0,0,0.8); color: #fff; padding: 12px; border-radius: 8px;
      font-family: monospace; font-size: 13px;
    }
    #pinsPanel {
      position: absolute; right: 12px; bottom: 12px; z-index: 20;
      width: 360px; max-height: 30vh; overflow:auto;
      background: rgba(255,255,255,0.95); color: #111; padding: 10px; border-radius: 8px;
      font-family: monospace; font-size: 13px;
    }
    canvas { display:block; }
    .btn { background:#2a6; color:#fff; padding:6px 8px; border-radius:6px; cursor:pointer; display:inline-block; margin-top:6px; }
    .small { font-size:12px; color:#ddd; }
  </style>
</head>
<body>
  <div id="detectedBox">Detected: <span id="detected">—</span></div>
  <div id="hint">Drag a sensor cube onto an MCU pin to connect. Hover a pin to highlight. Ctrl+drag to orbit camera; wheel to zoom.</div>

  <div id="probePanel">
    <div style="font-weight:bold; margin-bottom:8px;">Probe Log</div>
    <div id="probeLog" style="height:240px; overflow:auto; background:#111; padding:8px; border-radius:6px; color:#9f9;"></div>
    <div style="margin-top:8px;">Waveform (timing-accurate simulation)</div>
    <canvas id="waveform" width="320" height="120" style="background:#222; margin-top:6px; border-radius:6px;"></canvas>
    <div style="margin-top:10px;">
      <button id="clearLog" class="btn">Clear Log</button>
      <span class="small" style="margin-left:8px;">(times scaled for visualization)</span>
    </div>
  </div>

  <div id="pinsPanel">
    <div style="font-weight:bold; margin-bottom:6px;">MCU Pins</div>
    <div id="pinsList"></div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

  <script>
  // ----------------------------
  // Basic scene + camera + renderer
  // ----------------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf4f6f8);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(8,6,12);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.7);
  dl.position.set(6,10,6);
  scene.add(dl);

  // Grid
  const grid = new THREE.GridHelper(40, 40, 0xaaaaaa, 0xdddddd);
  scene.add(grid);

  // ----------------------------
  // MCU + connectors (pin-level)
  // ----------------------------
  const mcuGeom = new THREE.BoxGeometry(4, 0.9, 2.6);
  const mcuMat = new THREE.MeshStandardMaterial({color:0x223355, metalness:0.2, roughness:0.4});
  const mcu = new THREE.Mesh(mcuGeom, mcuMat);
  mcu.position.set(0, 0.45, 0);
  scene.add(mcu);

  // create connectors along two rows, labeled D0..D5 and A0..A3 for example
  const connectors = [];
  const connectorVisuals = new THREE.Group();
  scene.add(connectorVisuals);

  const pinDefs = [
    {name:'D0', side:'left'}, {name:'D1', side:'left'}, {name:'D2', side:'left'}, {name:'D3', side:'left'}, {name:'D4', side:'left'}, {name:'D5', side:'left'},
    {name:'A0', side:'right'}, {name:'A1', side:'right'}, {name:'A2', side:'right'}, {name:'A3', side:'right'}
  ];
  // positions relative to MCU center
  pinDefs.forEach((p,i)=>{
    const x = (p.side === 'left') ? -1.6 : 1.6;
    const z = -0.9 + (i % 6) * 0.35;
    const pos = new THREE.Vector3(mcu.position.x + x, 0.5, mcu.position.z + z);
    const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.03,12), new THREE.MeshStandardMaterial({color:0x222222}));
    cylinder.rotation.x = Math.PI/2;
    cylinder.position.copy(pos);
    connectorVisuals.add(cylinder);
    // name label (sprite)
    const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(0,0,256,64);
    ctx.fillStyle = '#000'; ctx.font='26px Arial'; ctx.fillText(p.name, 12, 40);
    const tex = new THREE.CanvasTexture(canvas);
    const spr = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
    spr.scale.set(0.9,0.25,1);
    spr.position.set(pos.x, pos.y+0.45, pos.z);
    connectorVisuals.add(spr);

    const connector = { name: p.name, position: pos.clone(), occupied: false, mesh: cylinder, sprite: spr, occupant: null };
    connectors.push(connector);
  });

  // Pins UI update
  function renderPinsList(){
    const el = document.getElementById('pinsList');
    el.innerHTML = '';
    connectors.forEach((c, idx)=>{
      const row = document.createElement('div');
      row.style.padding='4px 0';
      row.innerHTML = `<strong>${c.name}</strong> — ${c.occupied ? '<span style="color:green">occupied</span> by '+c.occupant.userData.type : '<span style="color:#888">free</span>'}`;
      el.appendChild(row);
    });
  }
  renderPinsList();

  // ----------------------------
  // create sensors (with metadata)
  // ----------------------------
  const sensorDefs = [
    {name:'DHT11', color:0x0088ff, protocol:'dht', preferredPin:'D2'},
    {name:'DS18B20', color:0xff5555, protocol:'onewire', preferredPin:'D3'},
    {name:'BMP280', color:0x55cc55, protocol:'i2c', preferredPin:'A0', i2cAddresses:[0x76, 0x77]},
    {name:'AnalogSensor', color:0xffdd55, protocol:'analog', preferredPin:'A1', analogVoltage: Math.random()*3.0 + 0.2}
  ];
  const sensors = [];
  sensorDefs.forEach((s,i)=>{
    const g = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshStandardMaterial({color:s.color});
    const mesh = new THREE.Mesh(g, mat);
    mesh.position.set(-9 + i*3.5, 0.6, -3);
    mesh.userData = Object.assign({}, s); // contains type, protocol, etc.
    scene.add(mesh);
    // label
    const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(255,255,255,0.95)'; ctx.fillRect(0,0,256,64);
    ctx.fillStyle = '#000'; ctx.font='26px Arial'; ctx.fillText(s.name, 8, 40);
    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
    sprite.scale.set(1.8,0.5,1);
    sprite.position.set(mesh.position.x, mesh.position.y+1.2, mesh.position.z);
    scene.add(sprite);
    mesh.userData.label = sprite;
    mesh.userData.connectedPin = null;
    sensors.push(mesh);
  });

  // pointer & ray for picking
  const ray = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  function setPointerFromEvent(ev){
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    ray.setFromCamera(pointer, camera);
  }

  // ----------------------------
  // dragging logic (plane intersection)
  // ----------------------------
  let dragging = null;
  let dragOffset = new THREE.Vector3();
  let dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

  renderer.domElement.addEventListener('pointerdown', (ev) => {
    setPointerFromEvent(ev);
    const hits = ray.intersectObjects(sensors, false);
    if (hits.length > 0) {
      dragging = hits[0].object;
      dragPlane.set(new THREE.Vector3(0,1,0), -dragging.position.y);
      const planePt = new THREE.Vector3();
      ray.ray.intersectPlane(dragPlane, planePt);
      dragOffset.copy(planePt).sub(dragging.position);
      renderer.domElement.setPointerCapture(ev.pointerId);
    }
  });

  renderer.domElement.addEventListener('pointermove', (ev) => {
    setPointerFromEvent(ev);
    if (!dragging) {
      // hover cursor for pickable sensors
      const hover = ray.intersectObjects(sensors, false);
      document.body.style.cursor = hover.length ? 'grab' : 'default';
      // highlight nearest connector for any hovered sensor? skip
      return;
    }
    const planePt = new THREE.Vector3();
    ray.ray.intersectPlane(dragPlane, planePt);
    if (planePt) {
      dragging.position.copy(planePt.sub(dragOffset));
      dragging.userData.label.position.set(dragging.position.x, dragging.position.y+1.2, dragging.position.z);
    }
    // highlight nearest connector to provide visual snap hint
    let nearest = null; let nd = Infinity;
    connectors.forEach(c=>{
      const d = c.position.distanceTo(dragging.position);
      if (d < nd) { nd = d; nearest = c; }
    });
    connectors.forEach(c=>{
      c.mesh.material.color.set(c === nearest && nd < 0.9 && !c.occupied ? 0x00ff88 : 0x222222);
    });
  });

  renderer.domElement.addEventListener('pointerup', (ev) => {
    if (!dragging) return;
    renderer.domElement.releasePointerCapture(ev.pointerId);

    // find nearest connector
    let nearest = null; let nd = Infinity;
    connectors.forEach(c => {
      const d = c.position.distanceTo(dragging.position);
      if (d < nd) { nd = d; nearest = c; }
    });

    // reset connector visuals
    connectors.forEach(c => c.mesh.material.color.set(0x222222));

    if (nearest && nd < 0.9) {
      // If occupied, reject unless same occupant (allow re-snap)
      if (nearest.occupied && nearest.occupant !== dragging) {
        logProbe(`Pin ${nearest.name} already occupied by ${nearest.occupant.userData.type}.`);
        // push away a little
        dragging.position.add(new THREE.Vector3(0.5,0,0));
        dragging.userData.label.position.set(dragging.position.x, dragging.position.y+1.2, dragging.position.z);
        dragging = null;
        return;
      }
      // If sensor was previously connected to another pin, free it
      if (dragging.userData.connectedPin) {
        const prev = dragging.userData.connectedPin;
        prev.occupied = false; prev.occupant = null;
      }

      // Snap to connector
      dragging.position.copy(nearest.position).add(new THREE.Vector3(0.6, 0, 0)); // place to side visually
      dragging.userData.label.position.set(dragging.position.x, dragging.position.y+1.2, dragging.position.z);
      dragging.userData.connectedPin = nearest;
      nearest.occupied = true;
      nearest.occupant = dragging;
      renderPinsList();

      // Visual: small green glow on pin
      nearest.mesh.material.color.set(0x00cc44);

      // Run simulated probe (timed and waveform)
      onSensorSnapped(dragging, nearest);
    } else {
      // not near any pin: just drop
      if (dragging.userData.connectedPin) {
        // if moved away, free previous pin
        const prev = dragging.userData.connectedPin;
        prev.occupied = false; prev.occupant = null;
        dragging.userData.connectedPin = null;
        renderPinsList();
      }
      document.getElementById('detected').innerText = '—';
    }

    dragging = null;
  });

  // ----------------------------
  // Probe UI + waveform canvas utilities
  // ----------------------------
  const probeLogEl = document.getElementById('probeLog');
  const wfCanvas = document.getElementById('waveform');
  const wfCtx = wfCanvas.getContext('2d');
  const clearLogBtn = document.getElementById('clearLog');

  function logProbe(msg){
    const row = document.createElement('div');
    row.textContent = `[${(new Date()).toLocaleTimeString()}] ${msg}`;
    probeLogEl.appendChild(row);
    probeLogEl.scrollTop = probeLogEl.scrollHeight;
    console.log(msg);
  }
  clearLogBtn.addEventListener('click', ()=>{ probeLogEl.innerHTML=''; });

  function clearWaveform(){
    wfCtx.fillStyle = '#222';
    wfCtx.fillRect(0,0,wfCanvas.width,wfCanvas.height);
  }
  clearWaveform();

  // Waveform drawing helpers: we will draw time samples left->right
  const wfSamples = []; // each sample: {level:0|1, durationMs}
  let wfPlaying = false;
  const TIME_SCALE = 0.02; // scale microseconds -> ms for visualization (1us -> 0.02ms). tweak for speed/visibility

  function pushPulse(level, durationUs){
    wfSamples.push({level: level?1:0, durationMs: durationUs * TIME_SCALE});
  }

  function drawWaveformFromSamples(samples){
    // compress samples to pixels
    wfCtx.clearRect(0,0,wfCanvas.width,wfCanvas.height);
    wfCtx.fillStyle = '#111';
    wfCtx.fillRect(0,0,wfCanvas.width,wfCanvas.height);
    const totalMs = samples.reduce((s, x) => s + x.durationMs, 0) || 1;
    let x = 0;
    for (const s of samples) {
      const w = Math.max(1, Math.round((s.durationMs/totalMs) * wfCanvas.width));
      wfCtx.fillStyle = s.level ? '#0f0' : '#333';
      const y = s.level ? 20 : 80;
      wfCtx.fillRect(x, y, w, 18);
      x += w;
    }
  }

  // Animated runner to show waveform progressively
  async function playWaveform(samples){
    wfPlaying = true;
    let elapsed = 0;
    const total = samples.reduce((a,b)=>a+b.durationMs,0);
    // create an expanding array to draw progressively
    let idx = 0;
    let drawn = [];
    while (idx < samples.length && wfPlaying) {
      drawn.push(samples[idx]);
      drawWaveformFromSamples(drawn);
      await new Promise(r => setTimeout(r, Math.max(8, samples[idx].durationMs)));
      idx++;
    }
    wfPlaying = false;
  }

  // ----------------------------
  // Simulated probe functions (timing-accurate pulses)
  // ----------------------------
  // scale: TIME_SCALE maps microseconds to ms to make pulses visible.
  async function simulateVoltageProbe(sensor){
    logProbe('Checking supply voltage (ADC) ...');
    await sleep(120);
    const v = sensor.userData.analogVoltage !== undefined ? sensor.userData.analogVoltage : 3.3;
    logProbe(`  voltage: ${v.toFixed(2)} V`);
    // simple waveform sample for voltage: show a DC level bar
    wfSamples.length = 0;
    pushPulse(1, 5000); // long high
    drawWaveformFromSamples(wfSamples);
    return {voltage: v};
  }

  async function simulateI2CScan(sensor){
    logProbe('Starting I²C bus scan (addresses 0x03..0x77) ...');
    const found = [];
    // simulate scanning some addresses then the sensor's known ones
    const addrs = [0x18, 0x1e].concat(sensor.userData.i2cAddresses || []).concat([0x40, 0x50]);
    for (const a of addrs) {
      await sleep(60);
      if ((sensor.userData.i2cAddresses || []).includes(a) && Math.random() > 0.05) {
        logProbe(`  ACK at 0x${a.toString(16)}`);
        found.push(a);
      } else {
        // rarely random ACK
        if (Math.random() < 0.02) { logProbe(`  ACK at 0x${a.toString(16)} (random)`); found.push(a); }
      }
    }
    // waveform: SCL toggles + ACK bits (simplified)
    wfSamples.length=0;
    for (let i=0;i<40;i++){ pushPulse(1, 5); pushPulse(0, 5); } // clock-ish
    drawWaveformFromSamples(wfSamples);
    return {found};
  }

  async function simulateOneWireProbe(sensor){
    logProbe('1-Wire reset: master drives low ~480us, device presence after 15-60us ...');
    wfSamples.length = 0;
    // master reset low 480us
    pushPulse(0, 480);
    // release, bus pulled high
    pushPulse(1, 70);
    // device presence pulls low 60-240us if present
    const present = sensor.userData.protocol === 'onewire' && !!sensor.userData.rom && Math.random() > 0.02;
    if (present) {
      const presLen = 60 + Math.floor(Math.random()*150);
      pushPulse(0, presLen);
      logProbe(`  1-Wire presence detected (ROM: ${sensor.userData.rom || '28-xxxx'})`);
    } else {
      pushPulse(1, 200);
      logProbe('  No 1-Wire devices found on the line.');
    }
    drawWaveformFromSamples(wfSamples);
    await playWaveform(wfSamples);
    return {present, rom: sensor.userData.rom};
  }

  async function simulateDHTProbe(sensor){
    logProbe('DHT style handshake: MCU drives low ~18ms, device replies with 40-bit data pulses ...');
    wfSamples.length = 0;
    // master start: low for 18ms (18,000us)
    pushPulse(0, 18000);
    pushPulse(1, 20); // release short
    // device response: 80us low + 80us high then 40 bits (50us low + high varies)
    // response sequence
    pushPulse(0, 80);
    pushPulse(1, 80);
    // bits: simulate 40 bits -> we'll simulate 5 bytes (hum, temp, checksum)
    for (let bit=0; bit<40; bit++){
      // each bit: 50us low
      pushPulse(0, 50);
      // high part: 26-28us for 0, ~70us for 1
      const isOne = Math.random() > 0.5;
      pushPulse(1, isOne ? 70 : 26);
    }
    drawWaveformFromSamples(wfSamples);
    await playWaveform(wfSamples);
    // decode to values (fake)
    if (sensor.userData.protocol === 'dht') {
      const humidity = 30 + Math.random()*50;
      const temp = 18 + Math.random()*14;
      logProbe(`  DHT reply: temp ${temp.toFixed(1)}°C, humidity ${humidity.toFixed(1)}%`);
      return {ok:true, temp, humidity};
    } else {
      logProbe('  No DHT response (no device).');
      return {ok:false};
    }
  }

  async function simulateSPIProbe(sensor){
    logProbe('Probing SPI: toggle CS, read ID ...');
    await sleep(180);
    if (sensor.userData.protocol === 'spi') {
      const id = 0xA1 + Math.floor(Math.random()*0x1F);
      logProbe(`  SPI device returned ID 0x${id.toString(16)}`);
      wfSamples.length=0; for (let i=0;i<40;i++){ pushPulse(0,4); pushPulse(1,4); }
      drawWaveformFromSamples(wfSamples);
      return {id};
    } else {
      logProbe('  No SPI response.');
      return {id:null};
    }
  }

  // small utility
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // ----------------------------
  // Heuristic probe coordinator
  // ----------------------------
  async function probeSensor(sensor, pin){
    document.getElementById('detected').innerText = 'Probing...';
    logProbe(`--- Probe start: ${sensor.userData.type} on pin ${pin.name} ---`);

    // 1. voltage check
    const v = await simulateVoltageProbe(sensor);
    if (v.voltage < 2.7) {
      logProbe('  Voltage too low; aborting.');
      document.getElementById('detected').innerText = 'No power';
      return;
    }

    // 2. If pin label suggests I2C lines? (we keep simple: run both i2c and one-wire/dht as necessary)
    let i2c = await simulateI2CScan(sensor);
    // for one-wire sensors probe on the same pin
    let one = await simulateOneWireProbe(sensor);
    let dht = await simulateDHTProbe(sensor);
    let spi = await simulateSPIProbe(sensor);

    // Decide
    let detected = null;
    if (one.present) detected = `1-Wire (${sensor.userData.type})`;
    else if (dht.ok) detected = `DHT (${sensor.userData.type})`;
    else if (i2c.found && i2c.found.length) detected = `I²C device @ ${i2c.found.map(x=>'0x'+x.toString(16)).join(',')}`;
    else if (spi.id) detected = `SPI id 0x${spi.id.toString(16)}`;
    else if (sensor.userData.protocol === 'analog' && v.voltage) detected = `${sensor.userData.type} (analog ${sensor.userData.analogVoltage?.toFixed(2)} V)`;
    else detected = `Unknown (simulated ${sensor.userData.protocol || 'unknown'})`;

    logProbe(`Probe result: ${detected}`);
    document.getElementById('detected').innerText = detected;
    logProbe('--- Probe complete ---');
  }

  // called when a sensor snaps to a connector
  function onSensorSnapped(mesh, connector) {
    // place mesh in a visible offset from the pin and mark connected
    mesh.position.copy(connector.position).add(new THREE.Vector3(0.6, 0, 0));
    mesh.userData.label.position.set(mesh.position.x, mesh.position.y + 1.2, mesh.position.z);
    // run async probe
    probeSensor(mesh, connector);
  }

  // ----------------------------
  // Animation / render
  // ----------------------------
  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // ----------------------------
  // Resize handling
  // ----------------------------
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // basic camera orbit with ctrl+drag + wheel to zoom
  let isOrbit = false, orbitStart = null, orbitTarget = new THREE.Vector3(0,0.6,0);
  renderer.domElement.addEventListener('pointerdown', (e)=>{
    if (e.button === 0 && e.ctrlKey) { isOrbit = true; orbitStart = {x:e.clientX, y:e.clientY}; renderer.domElement.setPointerCapture(e.pointerId); }
  });
  window.addEventListener('pointerup', (e)=>{ if (isOrbit) { isOrbit=false; renderer.domElement.releasePointerCapture(e.pointerId); } });
  window.addEventListener('pointermove', (e)=> {
    if (!isOrbit || !orbitStart) return;
    const dx = (e.clientX - orbitStart.x) * 0.004;
    const dy = (e.clientY - orbitStart.y) * 0.004;
    orbitStart = {x:e.clientX, y:e.clientY};
    const offset = camera.position.clone().sub(orbitTarget);
    const spherical = new THREE.Spherical().setFromVector3(offset);
    spherical.theta -= dx;
    spherical.phi = Math.max(0.3, Math.min(Math.PI - 0.3, spherical.phi - dy));
    offset.setFromSpherical(spherical);
    camera.position.copy(orbitTarget).add(offset);
    camera.lookAt(orbitTarget);
  });
  renderer.domElement.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const dir = camera.position.clone().sub(orbitTarget).normalize();
    const dist = camera.position.distanceTo(orbitTarget);
    const newDist = Math.max(3, Math.min(60, dist + e.deltaY * 0.01));
    camera.position.copy(orbitTarget).add(dir.multiplyScalar(newDist));
    camera.lookAt(orbitTarget);
  }, {passive:false});

  // Visual touches: label camera.lookAt update sync (not strictly necessary)
  window.setInterval(()=>{
    sensors.forEach(s => {
      s.userData.label.lookAt(camera.position);
    });
    connectors.forEach(c => { c.sprite.lookAt(camera.position); });
  }, 100);

  // console hint
  console.log('Pin-level sensor detection simulation initialized.');

  </script>
</body>
</html>
